1) Сначала js идет синхронно по всему скрипту в Call Stack попадает первый слушатель addEventListener().
js идет синхронно по первому слушателю, видит Promis и ставит его в очередь микро задач, затем видит console.log('Listener 1') и выполняет его.
Так как пока в первом слушателе не выполнится весь синхронный код и все микро задачи, в Call Stack не попадет второй слушаетель addEventListener().
Соответственно следующий console.log('Microtask 1').
Первый слушатель закончился, Call Stack освободился и теперь туда идет второй слушатель addEventListener() и выполняется все тоже самое.

Вывод:
Listener 1
Microtask 1
Listener 2
Microtask 2

2) Да разница будет, сначала наш скрипт находиться в стеке. Мы создаем нажатие с помощью js и синхронно вызываем события. 
Сначала в первом слушателе js так же синхронно идет по коду ставит в очередь микро задач Promis, затем видит console.log('Listener 1') и выполняет его.
Но так как наш Call Stack ещё не пуст! Js не вернул emptybutton.click мы переходим ко второму слушателю addEventListener().
И так же ставим в очередь микро задач Promis затем выполняем console.log('Listener 2')
Так как мы прошлись по всем слушателям, теперь наш Call Stack пустой Js вернул emptybutton.click 
и мы можем начать выполнять очередь микро задач в том порядке,в котором они были добавлены.

Вывод:
Listener 1
Listener 2
Microtask 1
Microtask 2

Отличие первого варианта от второго то, что мы создаем нажатие с помощью js.
мы проходимся по всему скрипту и не можем выполнять микро задачи пока наш Call stack еще не пуст, потому что нам не вернулся ответ от кнопки.
