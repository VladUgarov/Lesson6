1) Сначало js идет синхронно по всему скрипту в Call Stack попадедет первый слушатель addEventListener().
js идет синхронно по первому слушателю, видит Promis и ставит его в очередь микрозадач, затем видит console.log('Listener 1') и выполняет его.
Так как пока в первом слушателе не выполнится весь синхронный код и все микрозадачи в  Call Stack не попадет второй слушаетель addEventListener().
Соотвественно следущий console.log('Microtask 1').
Первый слушатель закончился, Call Stack овободился и теперь туда идет второй слушатель addEventListener() и выполняется все тоже самое.

Вывод:
Listener 1
Microtask 1
Listener 2
Microtask 2

2) Да разница будет, сначало наш скрипт находиться в стеке. Мы создаем нажатие с помощью js и синхронно вызываем собыития. 
Сначало в первом слушателе js так же синхронно идет по коду ставит в очередь микрозадач Promis, затем видит console.log('Listener 1') и выполняет его.
Но так как наш Call Stack ещё не пуст! Js не вернул emptybutton.click мы переходим ко второму слушателю addEventListener().
И так же ставим в очередь микрозадач Promis затем выполняем console.log('Listener 2')
Так как мы прошлись по всем слушателям, теперь наш Call Stack пустой Js вернул emptybutton.click 
и мы можем начать выполнять очередь микрозадач в том порядке в котором они были добавлены.

Вывод:
Listener 1
Listener 2
Microtask 1
Microtask 2

Отличие первого варианта от второго, то что мы создаем нажатие с помощью js.
мы проходимся по всему скрипту и не можем выполнять микрозадачи пока наш Call stack еще не пуст, потому что нам не вернулся ответ от кнопки.
